<!doctype html>

<html lang="en-us">

<head>
  <title>Superjomn&#39;s Blog</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="Superjomn" /><link rel="alternate" type="application/rss+xml+xml" href="http://superjomn.github.io/index.xml" title="Superjomn's Blog" /><meta name="generator" content="Hugo 0.62.0" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />
  <script src="https://kit.fontawesome.com/b76b73e8e8.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="/css/styles.css" /></head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="/">Superjomn's Blog</a>
            </h1>

      <ul id="social-media">
        
        
          
        <li><a href="https://github.com/Superjomn"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
           
      </ul>
      
      <p><em>Superjomn's blog</em></p>
      
    </header>

    
<nav>
    <ul>
        
    </ul>
</nav>

    <main>




<section id="home">
        <ul>
          
          <li class="first">
            <h1><a href="http://superjomn.github.io/posts/leetcode-sliding-window/" title="Leetcode Sliding Window">Leetcode Sliding Window</a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-01-10T00:00:00&#43;08:00">Jan 10, 2020</time>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/algorithm">#algorithm</a>
                
                    , 
                    <a href="/tags/leetcode">#leetcode</a>
                
            </em>
        </li>
        

        <li>5 minutes read</li>
    </ul>
</aside>

            <p>Permutation in String Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.</p>
            
            <a href="/posts/leetcode-sliding-window/">Read more…</a>
            
          </li>
          
          <li >
            <h1><a href="http://superjomn.github.io/posts/leetcode_jump_game/" title="Leetcode Jump game">Leetcode Jump game</a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-01-09T00:00:00&#43;08:00">Jan 9, 2020</time>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/algorithm">#algorithm</a>
                
                    , 
                    <a href="/tags/leetcode">#leetcode</a>
                
            </em>
        </li>
        

        <li>3 minutes read</li>
    </ul>
</aside>

            <p>[TOC]
问题 1 Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.</p>
            
            <a href="/posts/leetcode_jump_game/">Read more…</a>
            
          </li>
          
          <li >
            <h1><a href="http://superjomn.github.io/posts/leetcode_binary_devide_and_conqur/" title="Devide and conqur(分治法)">Devide and conqur(分治法)</a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-12-30T00:00:00&#43;08:00">Dec 30, 2019</time>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/algorithm">#algorithm</a>
                
                    , 
                    <a href="/tags/leetcode">#leetcode</a>
                
                    , 
                    <a href="/tags/devide">#devide</a>
                
            </em>
        </li>
        

        <li>2 minutes read</li>
    </ul>
</aside>

            <p>Binary search(BS)  方法一 方法二 C++ STL 函数 经典题    本文介绍分治法的一些思想和经典题。
Binary search(BS) BS 的复杂度是 \(O(\log N)\)
具体实现方法有两种
方法一 int a = 0, b = n - 1; while (a &lt;= b) { int k = a + (b - a) / 2; if (arr[k] == x) {.</p>
            
            <a href="/posts/leetcode_binary_devide_and_conqur/">Read more…</a>
            
          </li>
          
          <li >
            <h1><a href="http://superjomn.github.io/posts/design_pattern_builder/" title="Builer Design Pattern">Builer Design Pattern</a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-12-29T00:00:00Z">Dec 29, 2019</time>
        </li>
        

        

        <li>One minute read</li>
    </ul>
</aside>

            <p>简介 Builder Pattern 可以用来帮助创建构造函数很多备选参数的复杂类，比如定义一个 Computer 类
class Computer {public:Computer(GrapicsCard g, Monitor m, Process p, Memory ram):graphics_card_(g),monitors_(m),processor_(p),ram_(ram) { ... }private:GraphicsCard graphics_card_;Monitor monitors_;Processor processor_;Memory ram_;};// usageComputer compter(g, m, p, ram); // hard to readBuilder 能够以更可读的方式实现</p>
            
            <a href="/posts/design_pattern_builder/">Read more…</a>
            
          </li>
          
          <li >
            <h1><a href="http://superjomn.github.io/posts/design_pattern_visitor/" title="Visitor Design Pattern">Visitor Design Pattern</a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-12-29T00:00:00Z">Dec 29, 2019</time>
        </li>
        

        

        <li>3 minutes read</li>
    </ul>
</aside>

            <p>Visitor Pattern 用于表示对某种对象的操作，当增加新的操作时，无需修改被操作对象的代码。
使用前 比如，我们定义一类宠物，有两个实现猫(Cat) 和狗(Dog)；宠物都有抚摸(Stroke) 和喂食(Feed) 的操作
class Pet {public:virtual void Stroke() = 0;virtual void Feed() = 0;};对应实现 Cat 和 Dog 的两个操作
class Cat : public Pet {public:void Stroke() override { /* cat stroke way */ }void Feed() override { /* cat feed way */ }};class Dog : public Pet {public:void Stroke() override { /* dog stroke way */ }void Feed() override { /* dog feed way */ }};类似 Pet 这样的接口实现，会有如下问题：</p>
            
            <a href="/posts/design_pattern_visitor/">Read more…</a>
            
          </li>
          
          <li >
            <h1><a href="http://superjomn.github.io/posts/design_pattern_observer/" title="Design Pattern Observer 观察者模式">Design Pattern Observer 观察者模式</a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-12-28T00:00:00Z">Dec 28, 2019</time>
        </li>
        

        

        <li>One minute read</li>
    </ul>
</aside>

            <p>想象这样的场景，为气象站设计一整套系统，支持订阅功能，不同的仪器，比如手机、LED显示屏在天气发生大的变化时，会自动收到更新信息。
其中的挑战有
 订阅的设备的列表可能随时发生变化  比如，手机没电下线了；或者一个新的手机加入了订阅   气象站的带宽有限，订阅设备数可能很大  所以，无法支持每种设备简单 while(true) { sleep(20); request_for_data(); } 的实现   更新需要实时  类似这样的场景，就是观察者模式适用的。
接口定义 class Observable; class Observer { public: // Update the state of this observer.</p>
            
            <a href="/posts/design_pattern_observer/">Read more…</a>
            
          </li>
          
          <li >
            <h1><a href="http://superjomn.github.io/posts/halide-code-read-note/" title="Halide 代码阅读笔记">Halide 代码阅读笔记</a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-12-26T00:00:00&#43;08:00">Dec 26, 2019</time>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/halide">#halide</a>
                
                    , 
                    <a href="/tags/code-read-note">#code read note</a>
                
            </em>
        </li>
        

        <li>5 minutes read</li>
    </ul>
</aside>

            <p>前言 理解 Halide DSL 语法  Basics Vectorize, Parallelize, Unroll &hellip;   Type - 类型系统 IR  数学计算相关 IR 功能 IR 复杂 IR Stmt 和 Expr 的区别   IR 相关操作  Equality Print Simplify UnrollLoops VectorizeLoops   Lower  bounds inference slidding window simplify storage folding storage flattening vectorize loops unroll loops rewrite interleavings remove trivial for loops remove dead lets   Scope  前言 Halide 是一个用于图像处理加速的 DSL，其底层是一个相对完善的 NN Compiler，相关 IR 已经被 TVM, Tiramisu, Polymage 等多个项目使用。</p>
            
            <a href="/posts/halide-code-read-note/">Read more…</a>
            
          </li>
          
          <li >
            <h1><a href="http://superjomn.github.io/posts/leetcode-list/" title="Linked List Related Algorithms (WIP)">Linked List Related Algorithms (WIP)</a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-12-26T00:00:00&#43;08:00">Dec 26, 2019</time>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/algorithm">#algorithm</a>
                
                    , 
                    <a href="/tags/leetcode">#leetcode</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

            <p>链表常规操作（模板）  获取长度 拆分两半 判断是否有环   实际应用  对链表排序   经典题  由于是半路出家学的计算机，所以基础算法这部分一直没有搞的特别的清楚，长久在工作和日常思维方面的确对比 ACM 的同学有一定劣势。
但因为想长久从事这个行业，加上初步投入一定时间练习基础题后，自己觉得思维方面有一定的补充效果，所以决定长期做一些积累。
我会按多个文章来记录，每个文章聚焦一些主题，这样有利于整理一些思考。
所有的题目均来自 Leetcode，这样便于所见即所得；相应的编程语言，由于与算法无关，因此我会按方便所需混用 Python 和 C++。
链表常规操作（模板） 获取长度 def get_length(node): len = 0 while node: len += 1 node = node.</p>
            
            <a href="/posts/leetcode-list/">Read more…</a>
            
          </li>
          
          <li >
            <h1><a href="http://superjomn.github.io/posts/hugo/" title="通过 Org Mode 和 hugo 搭建 Blog">通过 Org Mode 和 hugo 搭建 Blog</a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-12-26T00:00:00&#43;08:00">Dec 26, 2019</time>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/howto">#howto</a>
                
                    , 
                    <a href="/tags/hugo">#hugo</a>
                
                    , 
                    <a href="/tags/emacs">#emacs</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

            <p>安装 Hugo emacs 中安装 ox-hugo 新建 hugo 站点 整体打通  本人用了 org-mode 已经很长一段时间了，主要的信息整理都完全通过 org mode 完成。 自己做一些笔记但毕竟琐碎，所以计划当知识逐渐成体系后，通过博文的方式做总结。
org-mode + ox-huge 是目前我能找到的最方便的工具，当然我本人最关注的是
 简单可靠 博客主题样式（默认）素朴，无需纠结 能复用 org-mode  安装 Hugo Hugo 是 golang 编写的博客系统，主要特性：</p>
            
            <a href="/posts/hugo/">Read more…</a>
            
          </li>
          
          <li >
            <h1><a href="http://superjomn.github.io/posts/leetcode_array/" title=""></a></h1> 
            <aside>
    <ul>
        <li>
            <time class="post-date" datetime="0001-01-01T00:00:00Z">Jan 1, 0001</time>
        </li>
        

        

        <li>0 minutes read</li>
    </ul>
</aside>

            <p></p>
            
          </li>
          
        </ul>
      </section>



</main>
    <footer>
        <h6> |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="http://superjomn.github.io/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="/js/scripts.js"></script>

</body>

</html>
